/**
 * |------------------------------------------|
 * | CO2 6502, COMPILER OPTIMIZER TO 6502     |
 * | File: semanticAnalyzer.h                 |
 * | v1.0, September 2012                     |
 * | Author: Emilio Arango Delgado de Mendoza |
 * |------------------------------------------|
 */

#ifdef __cplusplus

#ifndef SemanticAnalyzerH
#define SemanticAnalyzerH

#include "../gc.tab.h"
#include "../CommonFiles/symbolsTable.h"
#include <deque>
#include <string>
#include <list>
#include <functional>

#define SEM_FUNCTION_PREFIX "F_"
#define SEM_RETURN_SYMBOL   "return"

using namespace std;



/*
* Templates
*/
#pragma warning( disable : 4100 )
template <class T> struct assign : binary_function <T,T,T> {
	T operator() (const T& x, const T& y) const {return y;}
};
#pragma warning( default : 4100 )

template <class T> struct numerical_and : binary_function <T,T,T> {
	T operator() (const T& x, const T& y) const {return x&y;}
};

template <class T> struct numerical_eor : binary_function <T,T,T> {
	T operator() (const T& x, const T& y) const {return x^y;}
};

template <class T> struct numerical_or : binary_function <T,T,T> {
	T operator() (const T& x, const T& y) const {return x|y;}
};

template <class T> struct bitwise_left : binary_function <T,T,T> {
	T operator() (const T& x, const T& y) const {return x<<y;}
};

template <class T> struct bitwise_right : binary_function <T,T,T> {
	T operator() (const T& x, const T& y) const {return x>>y;}
};





/**
* Parser
*
* This class represents the parser and bridges the C and C++ code
*/

#include <fstream>
class Parser{

public:
	int             offset;
	int             nTokens;
	const char**    symbolNameTable;

	Parser();
	~Parser();
	int parse(ifstream*);
};





/**
* SyntaxTreeNode
*
* This class represents a node from the syntax tree generated by an input code file
*/
class SyntaxTreeNode {

private:
	inline void checkPrimaryExpression();
	inline void checkPostfixExpression();
	inline void checkArithmeticExpression();
	inline void checkRelationalExpression();
	inline void checkLogicalExpression();
	inline void checkConditionalExpression();
	inline void checkAssignmentExpression();
	inline void checkLabeledStatement();
	inline void checkSelectionStatement();
	inline void checkIterationStatement();
	inline void checkJumpStatement();
	inline void checkFunctionDefinition();

protected:
	bool returnDone;

	void          auxCheckExpression(function<int (int, int)>, const string &, bool, bool);
	QualifiedType extractQualifiedType (SyntaxTreeNode*);
	string        getNameAndDepthPointer(SyntaxTreeNode*, QualifiedType*, SyntaxTreeNode* &);
	string        getNameAndDepthPointer(SyntaxTreeNode*, QualifiedType*);
	void          performDefinition();
	void          performDeclaration();
	void          performVariableDeclaration();
	void          performFrameworkDeclaration();
	bool          isNewFramework();
	bool          checkInputTypeCorrectness(const string &, SyntaxTreeNode*);

	string        toString(const string &);

public:
	int	                   symbol;
	int	                   rule;
	int                    value;
	bool                   valueIsUsed;
	int                    line;
	string                 lex;
	QualifiedType          type;
	deque<SyntaxTreeNode*> children;

	SyntaxTreeNode(int symbol, int rule, int line);
	~SyntaxTreeNode();

	void           addChild(SyntaxTreeNode*);
	QualifiedType* typeCheck();

	string         toString();
};



/**
* SyntaxTree
*
* This class represents a syntax tree generated by an input code file
*/
class SyntaxTree{

private:
	SyntaxTreeNode* root;
	int             offset;
	int             nTokens;
	const char**    symbolNameTable;

public:
	SyntaxTree();
	SyntaxTree(int, int, const char**, bool);
	~SyntaxTree();
	bool            isLiteral(int);
	bool            isIdentifier(int);
	bool            isType(int);
	string          getSymbolName(int);
	void            setRoot(SyntaxTreeNode*);
	SyntaxTreeNode* getRoot();
	int             getNTerminals();

	QualifiedType*  typeCheck(bool);
	void            killUnusedSymbols();
	string          toString();
};





/**
* |------------------------------------------|
* |                                          |
* | Language dependant tasks                 |
* |                                          |
* |------------------------------------------|
*/

void initLanguageRequirements();
bool validateSemanticTree(bool);

#endif
#endif





/**
* |------------------------------------------|
* |                                          |
* | External C functions                     |
* |                                          |
* |------------------------------------------|
*/
#ifndef __cplusplus

#ifndef C_SemanticAnalyzerH
#define C_SemanticAnalyzerH

#include "../BackEnd/beErrMsg.h"
#include "../FrontEnd/feErrMsg.h"

void* newNode(int symbol, int rule, int line, ...);
void  addChildren(void*, ...);
void  setAsRoot(void*);

int   c_checkType(const char*);
void  c_newIdentifier(const char*);
void  c_newLiteral(const char*);
void  c_newType(const char*);

void  c_addError(const char*);
void  c_addWarning(const char*);
void  c_addInfo(const char*);

#endif
#endif
